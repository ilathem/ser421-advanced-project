## Analysis

Early web programming was difficult, as is usually the case for development associated with any new technology. Pages contained very little information, were ugly and did little outside of hosting strings of texts and associated images. In 1997, JavaScript was introduced - it would over time come to dominate web development. While there are many tools we have today to create sophisticated websites with easy, this wasn't the case in the early days. Various difficulties existed in the late 90's and early 00's that exposed a heavy demand for a better model of web programming. This led to our earliest front-end framework, jQuery. The successful of jQuery in helping to simplify web programming launched an arms race for which teams could create the most extensive and useful front-end frameworks to simplify programming and maximize the capabilities of the internet to present useful, dynamic and engaging web pages.<br></br>

Front-end frameworks have sought to improve the overall web environment, but they certainly have their drawbacks as well. Many of them are difficult to learn, and official documentation can be obtuse, poorly constructed and difficult to navigate or understand. This often presents a high learning curve, depending on the given framework and the complexity of the web page(s) that will be created. These frameworks often evolve quickly over time, with prior frameworks becoming somewhat obsolete over time as new versions are released with features that are often incompatible with older versions (i.e. Vue2 vs. Vue3). This means that there will be a significant and near-constant need for learning new framework concepts and abilities for any serious web developer. However, the alternative is worse. While it is possible to build any currently existing web page with vanilla JavaScript, it becomes exponentially more difficult when those pages become complex enough to resemble or compete with the best pages on the web today. It's not an overstatement to say that most of the best pages of the web today would be of far lower quality without the invention of client-side frameworks.<br></br>

We can expect new and better frameworks in the future, unless and until a higher-level concept comes along to replace the idea of the framework as a model for development. Each of these new frameworks will attempt to solve at least one given problem in web development, whether it is making the language easier to learn, optimization to further increase throughput and operation, etc. As of now, we can say that client-side frameworks, in particular the most popular ones, have been a massive asset for web developers and have improved the lives of the billions of web users around the world, and we strongly suspect that this will continue to be the case.


One shared goal of client-side frameworks is to provide an abstraction for manipulating the Document Object Model.  These frameworks differ in the ways in which they execute this shared purpose.  The ways in which these frameworks differ can broadly be organized into performance and syntactic differences.  

Performance:  
In an analysis comparing React, Vue, Angular, and Svelte, Mattias Levlin with the Abo Akademi University benchmarked the performance of these four frameworks in terms of the following four common types of DOM manipulation: DOM insertion, DOM editing, DOM removal, and compilation speed.  In order to compare these frameworks, the team manipulated the DOM in a series of tests that ranged from adding 1,000 `<div>` elements to editing 10,000 `<p>` tags.  

In their results,  they identified that Vue was the most performant in terms of speed for DOM insertion.  For DOM editing, Svelte was the fastest at finding and editing a single div element out of 10,000 while React was the fastest for editing all 10,000 elements.  Angular was the fastest for DOM element removal, and Svelte was the fastest for compilation speed.  In these findings, React and Vue performance often correlated with one another and Angular and Svelte performance often correlated with one another.  They believed these different clusterings were due to React and Vue using a virtual DOM, while Angular and Svelte did not.  

Syntax:  


